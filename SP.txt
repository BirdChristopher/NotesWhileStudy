1.zip 和 gzip都是将压缩包存到当前目录下.

2.linux权限管理中 -rwxrwxrwx的前三个是拥有者权限,中间三个是组用户权限,后三个是其他用户权限,r:read,w:write ,x:execute

3.apt-get是Debian系linux的专用安装方式(Redhat则是yum),wget则是一个下载工具,二者有区别.

4.gzip只用于压缩单个文件,不能用来压缩文件夹,如果压缩文件夹需要配合tar命令使用
tar 压缩命令: tar -czf <生成的文件夹名带.tar.gz后缀> <文件夹名>.
解压命令:tar -xzf <压缩文件名>
文档根本看不懂...记下来吧

tar命令选项
-c：（create）建立打包文件

    -t ：查看打包文件的内容含有哪些文件

   -x ：解打包或解压缩的功能，可以搭配-C(大写)在特定目录解开

    -j ：通过bzip2的支持进行压缩/解压缩，此时文件最好为*.tar.bz2

   -z ：通过gzip的支持进行压缩/解压缩，此时文件最好为*.tar.gz

   -v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来

   -f filename：-f 后面跟处理后文件的全名称（路径+文件名+后缀名）

   -C 目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项

   -p：保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件

5.ls
-s :显示文件大小
-b:显示文件大小
-h:将文件大小以可读方式展现
-l:展示所有文件的权限

6.要用vi的话要用sudo打开,否则无法保存,很几把难受

7.通配符:
用于文件匹配:
$匹配一个字符,
*匹配许多字符,
[list]list中任意单一字符
[!list]除了list中的任意单一字符
{string1,string2,...}匹配其中一个字符串

正则表达式:用于匹配字符串,针对文本内容的过滤工具.不同的系统,不同的语言有不同的规则.

8.linux系统中有隐藏文件的做法,一个方法是在文件名之前加.
另一个方法是在目录下建立一个.hidden文件,然后在文件中写想要隐藏的文件或者目录的名字
不过用ls -a或者ctrl+h是可以看到的哦

9.linux中的pushd命令:(栈顶的目录永远是当前目录)
pushd [path] 将一个目录入栈,并转到该目录
pushd            == cd -
pushd +n      转到栈中第n+1个地址,并将该目录放置到栈顶

popd             出栈
popd +n       将第n+1个出栈

dirs -p按行显示栈中目录

10.shell编程：tab键自动补全；
alias 命令重命名  
作业控制功能：在指令后加&可使进程在后台执行，这时可以同时执行多个任务。
用户环境个性化。

11.shell中">"符号可用于将输出重定向：比如 ls -l>a.txt,会将输出全部存进a.txt

12.bash脚本用#！来作为注释，但必须有一行注释来给出shell程序的位置，默认是#!/bin/bash
用逗号连接的算术操作都会被执行，但是只有最后一个表达式的值会被返回。

13.用户定义变量时用readonly修饰，将该变量变为只读的。

14.用；可一行书写多条命令。双引号内的字符串可以被转义，单引号内的全被视为普通字符。

15.在字符串中写用单引号括起来的命令，会使程序在输出字符串时先将命令的输出替换字符串中的命令，再输出修改过的
字符串。

16.shift命令允许存储大量位置参数。

17. 在bash脚本中使用x=$(date)可将一个命令的返回值作为变量存进x

18.(())括起来的内容只能用于变量自增或自减。

19.正则表达式中，如果不加^ or $来分别标记句子开头和结尾的话，输出的结果就是“包含正则表达式这一部分”的所有
内容。

20. grep 更适合单纯的查找或匹配文本
 sed 更适合编辑匹配到的文本
 awk 更适合格式化文本，对文本进行较复杂格式处理

21.;;是case结构中专属的分界符。。。不要乱用
由于bash脚本是一行一行执行的，所以不要像c语言一样把多个命令写在一行（比如if then else）除非；


22.流程控制有问题的话一定要关注各个结构的语法：
select  x in xxx xxx xxx xx
do 
	command
	break
done
一定注意break！ done！

if xxxx; 
then
	command
else
	command
fi
注意只有if和else if后面加then！
以及注意if 语句后面要加一个 ；结束！

while ((条件))
do
	command

done
同样注意收尾的标记符。

23.linux命令中，单引号和双引号会被区分，不要混用。

24.wc（我操）命令用于计算文件的大小，包括行数（-l），byte数等等

25.https://www.w3cschool.cn/awk/    awk的文档
awk中脚本部分的内容和C语言相似，if(condition){command;command;},
但是不需要类型定义，这一点和Python类似
脚本部分可以做一些简单的四则运算和条件运算，有一些内置函数可以完成较复杂的功能：比如字符串分割
脚本部分是单独的命名空间，与terminal中的命名空间不一样，可以用 -v x=$x把值传进去

26.硬链接是一个文件，存储一个inode地址，直接指向源文件指向的内存空间，文件的硬链接的数加一，
事实上只有把连接删干净了之后才会真正删除一个文件
软连接是一个文件，存储（文件系统意义下）源文件的存储路径

27.read函数会在读取的字节数不满足要求是等待来自标准输入的字节，造成阻塞。open是指定O_NONBLOCK
可以设置不阻塞，直接返回。

28.命令后加&可让命令在后台执行。 

29.文件的读和写锁是针对文件的某一位置设置的，不是针对整个文件设置的

30.pause(）函数将会让程序暂停，直到有信号出现。

31.fcntl可以对文件加锁，但是如果不对文件系统加入新的配置的话只能加建议锁，
如果对文件系统加入一项“自相矛盾”的配置（具体百度），将会是打算加强制锁的信号，此时
fcntl才会加强制锁。

32.对文件的系统调用函数都是以文件描述符作为定位标准，可以用int来代替l_type也可以用int表示
对目录的系统调用则需要指向目录的指针。声明为DIR *x。

33.文件系统中，每个文件都以结构体dirent的形式来整体处理。readdir()每次返回一个文件的dirent的地址，
所以我们一般用一个结构体指针来指向每次读取出来的结果。

34.awk -F '.*' 如果在-F之后跟的不止一个字符,那么就会被读取为正则表达式.-v用于将外部变量传入awk逻辑内部.

35.正则表达式的^用于锚定开头,$用于锚定结尾.