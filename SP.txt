1.zip 和 gzip都是将压缩包存到当前目录下.

2.linux权限管理中 -rwxrwxrwx的前三个是拥有者权限,中间三个是组用户权限,后三个是其他用户权限,r:read,w:write ,x:execute

3.apt-get是Debian系linux的专用安装方式(Redhat则是yum),wget则是一个下载工具,二者有区别.

4.gzip只用于压缩单个文件,不能用来压缩文件夹,如果压缩文件夹需要配合tar命令使用
tar 压缩命令: tar -czf <生成的文件夹名带.tar.gz后缀> <文件夹名>.
解压命令:tar -xzf <压缩文件名>
文档根本看不懂...记下来吧

tar命令选项
-c：（create）建立打包文件

    -t ：查看打包文件的内容含有哪些文件

   -x ：解打包或解压缩的功能，可以搭配-C(大写)在特定目录解开

    -j ：通过bzip2的支持进行压缩/解压缩，此时文件最好为*.tar.bz2

   -z ：通过gzip的支持进行压缩/解压缩，此时文件最好为*.tar.gz

   -v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来

   -f filename：-f 后面跟处理后文件的全名称（路径+文件名+后缀名）

   -C 目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项

   -p：保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件

5.ls
-s :显示文件大小
-b:显示文件大小
-h:将文件大小以可读方式展现
-l:展示所有文件的权限

6.要用vi的话要用sudo打开,否则无法保存,很几把难受

7.通配符:
用于文件匹配:
$匹配一个字符,
*匹配许多字符,
[list]list中任意单一字符
[!list]除了list中的任意单一字符
{string1,string2,...}匹配其中一个字符串

正则表达式:用于匹配字符串,针对文本内容的过滤工具.不同的系统,不同的语言有不同的规则.

8.linux系统中有隐藏文件的做法,一个方法是在文件名之前加.
另一个方法是在目录下建立一个.hidden文件,然后在文件中写想要隐藏的文件或者目录的名字
不过用ls -a或者ctrl+h是可以看到的哦

9.linux中的pushd命令:(栈顶的目录永远是当前目录)
pushd [path] 将一个目录入栈,并转到该目录
pushd            == cd -
pushd +n      转到栈中第n+1个地址,并将该目录放置到栈顶

popd             出栈
popd +n       将第n+1个出栈

dirs -p按行显示栈中目录

10.shell编程：tab键自动补全；
alias 命令重命名  
作业控制功能：在指令后加&可使进程在后台执行，这时可以同时执行多个任务。
用户环境个性化。

11.shell中">"符号可用于将输出重定向：比如 ls -l>a.txt,会将输出全部存进a.txt

12.bash脚本用#！来作为注释，但必须有一行注释来给出shell程序的位置，默认是#!/bin/bash
用逗号连接的算术操作都会被执行，但是只有最后一个表达式的值会被返回。

13.用户定义变量时用readonly修饰，将该变量变为只读的。

14.用；可一行书写多条命令。双引号内的字符串可以被转义，单引号内的全被视为普通字符。

15.在字符串中写用单引号括起来的命令，会使程序在输出字符串时先将命令的输出替换字符串中的命令，再输出修改过的
字符串。

16.shift命令允许存储大量位置参数。

17. 在bash脚本中使用x=$(date)可将一个命令的返回值作为变量存进x

18.(())括起来的内容只能用于变量自增或自减。

19.正则表达式中，如果不加^ or $来分别标记句子开头和结尾的话，输出的结果就是“包含正则表达式这一部分”的所有
内容。

20. grep 更适合单纯的查找或匹配文本
 sed 更适合编辑匹配到的文本
 awk 更适合格式化文本，对文本进行较复杂格式处理

21.;;是case结构中专属的分界符。。。不要乱用
由于bash脚本是一行一行执行的，所以不要像c语言一样把多个命令写在一行（比如if then else）除非；

22.exec本事并不是函数，其代表一个函数族，包括常用的execvp


22.流程控制有问题的话一定要关注各个结构的语法：
select  x in xxx xxx xxx xx
do 
	command
	break
done
一定注意break！ done！

if xxxx; 
then
	command
else
	command
fi
注意只有if和else if后面加then！
以及注意if 语句后面要加一个 ；结束！

while ((条件))
do
	command

done
同样注意收尾的标记符。

23.linux命令中，单引号和双引号会被区分，不要混用。

24.wc（我操）命令用于计算文件的大小，包括行数（-l），byte数等等

25.https://www.w3cschool.cn/awk/    awk的文档
awk中脚本部分的内容和C语言相似，if(condition){command;command;},
但是不需要类型定义，这一点和Python类似
脚本部分可以做一些简单的四则运算和条件运算，有一些内置函数可以完成较复杂的功能：比如字符串分割
脚本部分是单独的命名空间，与terminal中的命名空间不一样，可以用 -v x=$x把值传进去

26.硬链接是一个文件，存储一个inode地址，直接指向源文件指向的内存空间，文件的硬链接的数加一，
事实上只有把连接删干净了之后才会真正删除一个文件
软连接是一个文件，存储（文件系统意义下）源文件的存储路径

27.read函数会在读取的字节数不满足要求是等待来自标准输入的字节，造成阻塞。open是指定O_NONBLOCK
可以设置不阻塞，直接返回。

28.命令后加&可让命令在后台执行。 

29.文件的读和写锁是针对文件的某一位置设置的，不是针对整个文件设置的

30.pause(）函数将会让程序暂停，直到有信号出现。

31.fcntl可以对文件加锁，但是如果不对文件系统加入新的配置的话只能加建议锁，
如果对文件系统加入一项“自相矛盾”的配置（具体百度），将会是打算加强制锁的信号，此时
fcntl才会加强制锁。

32.对文件的系统调用函数都是以文件描述符作为定位标准，可以用int来代替l_type也可以用int表示
对目录的系统调用则需要指向目录的指针。声明为DIR *x。

33.文件系统中，每个文件都以结构体dirent的形式来整体处理。readdir()每次返回一个文件的dirent的地址，
所以我们一般用一个结构体指针来指向每次读取出来的结果。

34.awk -F '.*' 如果在-F之后跟的不止一个字符,那么就会被读取为正则表达式.-v用于将外部变量传入awk逻辑内部.

35.正则表达式的^用于锚定开头,$用于锚定结尾.

36.子进程会复制父进程的输出缓存区！可以用fflush或者加\n清空缓存区。

37.C语言的signal函数在执行之后，会在运行其后代码的过程中一直等待信号。所以一般写在函数最前头就行。

38.C语言的<函数名>就是这个函数函数指针。当然函数指针可以传递。

39.如果c程序中使用了数学函数，那么编译时要在尾部加 -lm ，否则编译报错。

40.sigaction函数：https://blog.csdn.net/weibo1230123/article/details/81411827
相当复杂。。。。sa_sigaction的第三个参数一般没用，siginfo参数形式如下

siginfo_t {     // handle信号处理函数的第二个参数    
                int si_signo; // 信号的值
                int si_code;  // 信号来源:SI_USER.SI_TKILL.SI_QUEUE.. 
                pid_t si_pid;    // 信号发送进程的进程 ID 。
                uid_t si_uid;   //信号发送进程的真实用户 ID 。
                union sigval si_value; //sigqueue 函数发送信号时所带的伴随数据。
                ...
            }
所以不只有发送者给出的信息，还有一些有关发送者自身的信息。


41.sigprocmask是对指定信号集的全程阻塞，被阻塞的信号不能在被信号处理函数捕捉，直到修改sigprocmask的信号集解除
该信号的阻塞。

42.进程之间使用的内存空间是隔开的，所以一个进程传递信号时如果给出一个指针，那么毫无意义。。。。拿到了指针也访问不了。

43.C语言的启动参数：int main(int arg_num,char **args),如果要用启动参数就必须两个都给全，否则会有SIGSEGV

44.一个坑：execv(char *filepath, char *args[])中args的最后要用null指针来结尾，否则调用失败。用execl类的就不会有这个问题。

45.对于多任务处理系统，一般来讲，CPU 核心数远低于当前系统中同时存在的进程数，因此，某一时刻，大概率总有一些进程处于非运行时状态。
但这些进程在未来的一些时刻又将会被调度执行，恢复到之前该进程被终止时候的状态。因此，有必要把一个进程被终止时的信息记录下来。
这些信息被称为进程控制块 PCB（Process Control Block），主要包括进程被终止时各个寄存器的使用情况、父进程 ID、进程组 ID 等。
操作系统可以通过进程的 ID，找到该进程的 PCB。

46.- 进程在执行时会改变状态，每个进程可能处于以下状态：
  - 新的(`new`)：进程正在创建。
  - 运行(`running`)：指令正在执行。
  - 等待(`waiting`)：进程等待发生某个事件（如`I/O`完成或收到信号）。
  - 就绪(`ready`)：进程等待分配处理器。
  - 终止(`terminated`)：进程已经完成执行。
- 一次只有一个进程可在一个处理器上**运行**(`running`)
- 可以有多个进程处于就绪(`ready`)或等待(`waiting`)状态

等待和就绪的区别：等待过程中内核不可能为其分配资源，因为程序的逻辑上还要等其他进程结束才行。
就绪：就绪发生在等待结束之后，此时进程不一定立即恢复执行，还需要等其他进程让出资源

47。标准输入，标准输出，出错信息的文件描述符（分别为0,1,2）在一个进程中不是默认存在的，只是默认命名为0，1，2，
所以在创建daemon进程的时候并不需要关闭这三个描述符。open()系统调用返回的就是打开文件的文件描述符（int）。

48.一个终端控制的进程会在终端关闭之后全部退出，这跟进程组组长的原理不同，进程组组长的唯一意义在于将其PID作为进程组
PID。也就是说进程组组长退出不会导致成员也退出。

49.通常我们登录用户时会产生一个会话，退出时该会话结束。属于该会话的进程（比如我们开的浏览器、音乐播放）在该会话结束时都会被终止。

50.当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。

51.一个shell中运行所有进程都是bash进程的子进程，但是bash进程的所有子进程并不一定都在一个进程组内。
shell本身不是进程。
内核向一个进程组发出信号之后，进程组内的所有进程都会收到。
当然内核是可以选择一个特定的进程发出信号的。

52.进程组，会话组的意义在于方便管理，可以批量地管理进程。比如利用进程组批量地向进程发送信号。
事实上，所有在bash中使用命令运行起来的进程都会单独开辟一个进程组。

53.重定向产生的原因就是文件描述符在分配时趋向于数值小的，而在用户层，stdout （标准输出）这个文件指针指向的文件已经封装了，
并且它的 fd 就是 1，这是不能修改的，所以我们一上来关闭了 1 号文件，然后新创建了一个文件它的文件描述符就会分配为被 1，同时此时写入时，
像 `printf` 这类函数默认使用的输出流就是 stdout，但是我们知道它的 1 指向的已经是我们新生成的那个文件了，所以这就是重定向的本质。

54.管道分为匿名管道和命名管道。 匿名管道创建后本质上是 2 个文件描述符，父子进程分别持有就能够使用管道，
需要注意的是不能够共用匿名管道，也就是除了使用的进程，其他进程需要关闭文件描述符，保证管道 的 2 个描述符"分别"同时只有 1 个进程持有。

55.dup2()与dup()的区别在于，dup2会在将文件描述符复制给newfd时先将newfd对应的原文件关闭。dup()则没有这一步骤

56.strlen()不包含\n。。。write和read好像会自动做一些加“\0”的操作啥的，搞不太清楚