1.在将二维数组作为参数传入函数的时候，不能用int **的形式。。。
虽然结构相似，但其实由于二维数组在内存中的特殊结构，写了会报错
有三种方法：
(1):  直接传num[M][N]
(2):  num[][N]
(3):  int (*a)[N]

2.对于int **x，*x[i] == *(x[i])

3.x<<1+1 = x*4 而不是x*2+1！！！

4.函数传参，只传形参，若要传递一个想要被实时修改的值，请传它的指针

5.memcpy(void * dest, void * src, unsigned num)
注意要自定义传输的字节的数目

6.strcpy的效率会比一个一个复制高一点？反正没memcpy高就是了

7.qsort函数的比较函数返回值中，-1是不需要交换，1是需要交换；
    还有一点需要注意！
	假如我们需要排序的是一个二维数组，那么二维数组的指针定义形式为：
	int **num，而不是int *num，那么在对二维数组排序时，比较函数的定义
	必须也是int **x，int **y，if(**x>**y)这样写；
	和一维数组的排序有很大区别！！！一定注意

8. int **x

9.memset()，memcmp()

10.注意：对于函数接口的返回值为数组指针时，不要用int x[10000];return x;来返回结果！！
因为返回的只是指向该数组的指针，局部变量在函数退出的时候会销毁，所以由于x[10000]中的所有元素都只在该函数的栈帧上，退出
的时候就失效了，最好使用static 修饰x或者用malloc，为数组分配一个栈帧之外的地址，这样就没有问题

11.注意：int *p[100]是一个有一百个指针的数组，
  int (*p)[100]是一个指针，指向一个有一百个元素的数组，p+1将会偏移100*sizeof(int)

12.C++知识点：引用不是指针！引用可以在某种程度上可以被认为是某个数据第二个标签
主要有以下几点不同：1。不存在空引用；
		2。一旦引用被初始化了，就不能再引用其他地址的内容
		3。引用必须在创建的时候被初始化，而指针可以在任何时间被初始化
当然除了这些不同，它跟指针在本质实现方式上没有区别。引用的本质就是常量指针，
且由于引用不会额外分配空间，所以是不可以在初始化引用的时候直接为其赋一个常数值的。

13.c++支持设置函数的默认值

14.c++在代码书写顺序上，不允许先调用函数再实现函数，这与c语言是很大的不同

15.c++的类型限定符：const类型的对象在程序执行期间不能被修改
volatile的意思是告诉编译器不需要优化该数据
restrict的作用是，其修饰的指针是唯一一种访问它所指向的数据的方式
不知道有什么用

16.c++的auto存储类会自动根据初始化的数据类型自动推断变量的类型

17.extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，
可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

18.c++中定义命名空间的方法：
namespace namespace_name {
   // 代码声明
}
然后调用命名空间中的函数或变量时，用name::code的方式来调用；
其实我们一般常见的using namespace std并不是科学的，这样就失去了标准库划定命名空间避免混淆的意义了
就算使用了using namespace std指定了以后，仍然可以使用其他命名空间中的函数，
比如使用ios空间中的文件操作函数open等等，但是就必须要加name::来修饰了
还可以使用using std::cout这样的方法来只引用命名空间中的某一个函数
注意，标准库中的函数的命名空间都是std

19.后缀带.h的库（比如stdlib.h）,c99标准已经明确说明不支持了！带.h的都是旧版的库，
命名空间都是全局空间，这样的坏处就是有可能在我们自定义变量时变量名与旧版库里的变量名
冲突。

20.c++的文件操作需要先生成一个ifstream实例对象，再调用.open（path,option）方法打开指定路径下的文件，
option里的选项都是ios命名空间下的，所以得写成ios::(opt)
总结：与c语言不同，c++对文件的操作不是函数，而是ifstream或者ofstream实例对象的实例方法（ifstream对象不支持写操作）
但是向文件写入和读出还是用流插入符<<和>>

21.事实上cin和cout根本不是函数，他们其实是标准输入对象和标准输出对象，一般来说是键盘和屏幕，
他们也有自己的方法。cin>>data 和 infile>>data是完全一致的规则(因为规则完全由>>来决定，cin和infile只是决定输出到哪里)

22.用>>读入是可以过滤掉不可见的字符的
一些输入用法：
1.cin.getline(char* str，num) 接受一个字符串，可以接受空格并输出（最多num个字符）
2.cin.get(x)可以用于接受字符，也可以用cin.get(x,num)表示接受一个长度最多为num的字符串到字符数组x，
可以接受空格
3.cin>>可以接受数或者字符串，但是字符串会在接收到空格时停止
4.cin.ignore()跟getchar（）差不多
对应的，infile之类的ifstream和ofstream对象也有类似的方法。

23.c++的内联inline修饰的函数是一个对编译器的建议，建议编译器将主函数调用函数时，将call func改写为
直接运行函数内的流程，相当于一种对代码的改写，把函数内的代码直接copy到call func的地方，这样做的好处
是可以不用开新的栈帧来运行函数，缺点是如果函数本身逻辑复杂或者重复调用太多次会使代码量过度膨胀，
占用太多内存

24.C++模板的意义是可以编写与数据类型无关的代码

25.C语言不要写出类似1<<x<<3之类的判断条件。。。这种判断没有意义的。

26.c++中的类方法既可以在类中实现，也可以在类中先声明，再在类外实现，但此时要用::指明语义空间。
二者的区别是，前者的函数只能在类中使用，是局部的，而后者可以被其他文件引用。

27.strcpy，strstr等函数在cstring库中

28.c++类中的protected变量可以被派生子类访问到

29.一个类的构造方法不能写返回值！无论在python和c++都是这样的

30.类实例化时只为类的非静态属性分配了新空间，类方法是共享内存的

31.this是一个指针常量，不能修改的呢。其实对于类方法而言，用this指针去提取其非静态成员属性是没有必要的。。。
事实上不需要this指针来指向哪一个实例，类方法都只会使用本实例的成员。

32.在子类继承的时候，不会继承：基类的构造函数，析构函数，友元函数，重载运算符，拷贝构造函数


