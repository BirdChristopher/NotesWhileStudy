1.Java中System.out.print()默认不换行输出System.out.println()默认换行‘
printf则是继承c语言的特性，可以进行格式化输出，注意还有一些python的特点，可以控制对齐，占位符等等。

2.java中int的封装类是integer，Integer的类方法valueOf（String）可以用于将String转换为数字，但注意是转换为封装类的Integer
而parseInt是转换为基本的int类型数据

3.不要在类的属性定义中做任何操作，类定义是由一个一个声明构成的，比如函数声明，属性声明,还可以初始化，其他的对变量操作等操作
应被放入函数内完成。

4.java中整数类型默认int，小数默认double

5.java中用final来修饰常量，对应c++中的const

6.String类的toCharArray()方法，可以将字符串转换为字符数组
valueOf方法将字符数组转换为string

7.String k = new String(c),这里的参数c可以是一个字符数组或者给定的一句话，利用构造方法可以直接生成想要的string

8.面向对象编程中也是有变量作用域的说法的，在一个类方法中定义的变量是不能拿出来用的~，但是成员变量是可以在类方法中使用的

9.java支持int a[][]这样的方式声明二维数组

10.java中int a[] 和 int[] a是一个意思，都是声明一个数组，java二维数组的声明可以暂时不声明列数，但是必须要声明行数，意思就是说
可以每一行的长度根据情况定义

11.java的switch语句中default语句在没有break的情形下也会受到down through影响

12.java将数组作为参数传参时，本质是传指针，just like c/cpp

13.java的短路机制！！很寄吧有用

14.javaScanner对象的方法还有in.nextInt，in.nextFloat之类，可以很方便的获取单个数据。

15.java的只有类能被import，类方法是不能被import的。

16.String的toCharArray方法可以将字符串转换为字符数组。

17.for循环语句里面支持另一种表达for(int i : <数组>)，这个跟python的的for in 迭代器语句是一样的。
但是好像这个i不能再循环语句外声明，非常的奇怪。为什么？？？

18.java中数组和类对象都是引用类型的数据

19.clone()方法是浅拷贝的，并且必须重载才能使用（加上报错语句），否则无法编译

20.java得对象生成也是用class()来生成的，记得加括号

21.java函数的编写中适用可变参数列表，但是一个列表中的参数只能是同一种数据类型，最终传入的是一个数组的引用，
当然也可以是String[]。所以说对于声明了可变参数列表的函数，可以一个一个地将参数写进去，也可以直接传一个数组，
反正传进去都是一份引用。并且可变参数列表的空间在堆中，意味着不会随着类方法结束被释放！（同样必须是参数列表的最后一项）

22.String a = new String("hello")是冗余的写法。虽然不会报错。

23.java常量池：分为静态常量池和运行时常量池，一般我们考虑的是运行时常量池。对于程序中的字面量，如果不同的String的字面量相等，
编译器只会为这个字面量分配一份空间，所有的String都引用一个地址。

24.对象存储在堆中

25.
1.java中从java.utils中导入的scanner类是专门用于读取用户输入的一个类，有四个常用的类方法：
	1.in.next():自动忽略前导空格，读入一个String，到空格处停止。并且一定要读取到有效字符后才可以
结束输入，意味着如果不输入一直回车，程序会保持等待输入的状态
	2.in.nextLine()以enter为结束符。
	3.in.hasNext()判断标准输入中是否还有字符未读取
	4.in.hasNextLine()判断标准输入中是否含有行没有读取。

2.String对象可以与字符变量做连接运算。

3.有关\r ,\n的知识：（来自于机械打字机）
\r：回车符，用于将输入光标移到行首，\n则是换行符，用于新启一行；
在不同的系统中，真正的换行的完整表示不一样。比如在windows中是\r\n,unix中是\n,mac中是\r。
但是一般在我们编码的时候，编译器会将\n视作换行回车，而在一般输入的时候将enter键视为\r\n两个绑定，
所以一般不用考虑区别，除了少数编写文件的情形。

4.java中==关键字比较的是两个对象的地址，而equals比较的是值

5.String字符串的运算：如果与数字加法，那么会将数字十进制表示完整的加入字符串显示
如果与字符串类型，直接连接，如果与字符类型，则直接连接。
但是注意，如果一个用+连接String时，字符变量，string和数字同时出现，那么可能出现问题。

26.JAVA内置的java.utils.Array类中的类方法Array.sort(nums[])是一个优化过了的排序函数。
对于ArrayList不能用什么交换位置之类的方法手动操作,先用toArray转换为list，再用Array.sort(），效率很低。

27.final变量是：如果在编译时能知道一个变量（包括String）的确切值，那么编译器会将其替换为常量，
相当于c语言中的宏替换。比如说，所有的string对象都是final的
final类：不允许这个类被继承
final方法：不允许子类修改其机制，且能提高运行效率

28.为什么类中的全局变量会被初始化为默认值，而局部变量必须手动初始化才能使用？这是JVM内部的规则决定的，
局部变量的内存在栈上，相对难管理。手动初始化将会提高程序性能并且降低程序出错的可能性，所以JVM规定必须手动初始化。

29.复合赋值符如 a+=5 等价于a = (a的类型)（a+5），可能带来高位截断的问题。
并且java规定，当一个算术表达式包含多个基本类型的值时，整个表达式的数据类型将会自动升高为最高类型。
当然不会发生int->double这样的变化。

30.java也有this关键字，同样也一般用于处理重名的情况，还可以用于在类方法内部调用构造方法

31.构造方法一般来说都是需要重载的。书写构造方法的时候不能加返回值（加了返回值编译没有问题，但是这个方法就不再是构造方法了），
不能有static修饰符。
构造方法可以在方法内部被再次调用，可以用this(args[])来调用类的构造方法，这个时候和普通方法的作用域啥的一样。

32.java没有提供析构方法，但是提供了类似的方法 protected void finalize()，作用是类似的，
修饰符可以选择protected void。析构方法是需要指定返回值的。

33.toString方法事实上是否显式的写出来无所谓。调用打印函数的时候会自动调用。当java要打印一个空串或者别的null值时，它不是
什么都不输出，而是输出‘null’字符串。
toString方法需要重写才能使用。

34.隐藏 和覆盖 的区别在于，子类对象转换成父类对象后，能够访问父类被隐藏 的变量和方法，而不能访问父类被覆盖 的方法。
变量只会被隐藏，不会被覆盖。
不能隐藏private变量，final方法；
隐藏成员变量时只要同名即可，可以更改数据类型。

35.ArrayList<类名>()可以使用变长数组，ArrayList不能用于生成基本数据类型的变长数组。
要注意ArrayList.sort()函数只能排列Object[]或者基本数据类型的列表。
因为类的初始化需要调用构造函数，所以要加括号（）
。
36.若需要将一个String 以 . （或者|）为基准切开，需用str.split("\\.")（或者str.split("\\|")），这是两个特殊情况。

37.JAVA被private修饰的方法默认是final的

38.多态不涉及成员变量，只涉及方法。静态方法不能多态（因为可以在未被实例化时使用）,只能被子类对象隐藏，
因此不存在动态联编，父类调用方法时就单纯地调用父类中定义的方法。只有动态方法可以用多态

有关这一点的一个理解是，当存在父类引用指向子类方法时，静态方法由引用类型决定，普通方法由对象类型决定。
将这一点和java类的内存规则结合很容易理解了

在书写的时候，父类必须已经声明了该被多态的方法，否则不能多态，编译错误。


39.java的类加载都是懒加载。

40.java的instanceof 关键字判断左值是不是右值的实例化。

41.好像public的类必须单独占一个java文件？

41.重写：子类遮盖父类的方法 
    重载：一个方法签名多种实现方式
enum类中的成员类是可以重写enum类中的方法的。

42.继承接口时是可以继承到接口中定义的变量的。

43.java的非静态内部类初始化必须要求其所对应的外部类已被初始化，构造语句形如Outer.Inner oi = new Outer().new Inner()
写法比较特别。

44.内部类和外部类在内存上并无联系，只是内部类自动持有指向外部类的引用而已。
但是内部类的变量可能因为与外部类变量同名而覆盖外部类成员的引用。此时就需要在内部类中
重新new一个外部类出来，这样就可以access外部类的成员了。

客户类不能直接访问到内部类，但是可以设置方法把内部类漏出来。

45.匿名类的本质在于隐藏了接口和父类。
interface Inter {
    void show();
}

class Outer {
    static public Inter method(){
        Inter a = new Inter(){
            public void show(){
                System.out.println("oo");
            }
        };
        return a;
    }
}
比如上面的代码中，a就是一个匿名的类，继承了Inter接口，并且重写了show方法。就不需要重新定义一个类来
继承Inter接口了，书写比较方便。

46.工厂模式经常和单例模式一起出现。虽然如果是匿名类实现的工厂模式就做不到了。
工厂模式的内涵在于，由于构造方法不能像Python那样被引用，被当成变量一样传来传去，但是一个类可以
被当成变量传递。所以工厂类就承载了某一个特定的构造方法，完成这个构造方法的代言人的作用。
所以很优秀吗？

47.java支持用变量定义列表长度，这一点比c语言先进

48.java类的强制类型转换必须要声明一个新的引用，
比如car x=(car)y;
而不能直接写y=(car)y

49.内部类自动持有外部类的引用，但是内部类并没有拥有一个显式的引用来指向外部类对象。必须在外部类中
创建一个方法来返回指向外部类对象自己的引用 (this) ，再相办法在内部类中调用哪个方法才行。

50.静态内部类的特殊之处就在于，可以在外部类对象压根就没有的时候创建内部类。

51.Java的String.substring方法可用于截断字符串

52.当class类中的方法调用另一个类anotherClass中的方法func()时，func的命名空间仍在anotherClass中，
并可以访问anotherClass中的所有成员和方法

53.一个类对象.getClass可以获得对其类的引用，通过一系列方法可以获得这个类的构造方法，名字等信息。

54.泛型方法：泛型的本质在于不确定的参数类型。泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。
在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，
而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。
对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。
泛型的出现就是为了解决这个隐患

访问修饰符 [static][final] <类型参数列表> 返回值类型 方法名([形式参数列表])

备注:[] 代可有可无的意思，泛型方法可以是实例方法或静态方法，类型参数可以在静态方法中，这是与泛型类最大的区别。



55.泛型方法可以让不同方法操作不同类型，且类型还不确定。事实上，对任何涉及到Object的类或者方法，都可以指定泛型。

与泛型类不同，泛型方法的类型参数只能在它所修饰的泛型方法中使用。

？,T,K,V这些符号在使用时无本质区别，但是习惯上T为任意类，？为无界通配符，往往用于在泛型类中定义方法时。

56.记住构造方法的执行顺序：如果先执行父类，再执行子类。

57.父子构造方法，静态代码块，普通代码块的执行顺序。。。。。

58.反射：
Class Foo{}
Foo的对象 是 Foo f1=new Foo();
但是 Foo类 也是一个对象，它是Class类的对象，只有java的虚拟机 可以访问Class.java的构造方法 从而构造出任何Class

任何一个类都是Class的实例对象。

59.IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。

60.java的注解包括元注解和普通注解，普通注解继承@interface（@interface是一个注解接口）并由元注解声明作用空间和
生效时间。注解中可以包含的数据类型有限，像ArrayList就不允许存在于注解中

注解中不包含任何的方法，只有成员属性。

61.注解不允许使用extends来继承，所以继承Interface都是直接加@Interface在前面。

62.比如@Override就指定了只在源码中起作用，所以一般来说重写方法加不加@Override没有区别。

63.标记了@Inherited的类在被继承的时候，子类通过反射机制getAnnotation()可以获取父类被@inherited注解了的注解。

64.注解基本上就是与反射技术绑定的，解析注解的控制代码根据getAnnotation之类的方法拿到注解信息，再根据注解信息
决定如何使用被注解修饰的内容。

65.maven是根据启动项目时的设置动态给出依赖的，其拿到依赖的源在国外。并且一个项目的依赖往往很庞大。可以修改maven的
源为alibaba镜像。

66.java中如果一个方法被throws标记，那么调用这个方法的caller必须用try--catch结构。如果callee没有被throws标记，那么就可以
在方法内部直接处理异常。

67.对于一些在很多类中都要用的工具对象，比如说Scanner in，完全可以在所有的类读取输入时都从test类中的scanner中读取，或者test类
定义一个读取输入的方法，然后由其他类调用，这样就不需要把scanner传来传去。
还有一些非常常用的，完全可以复用的工具函数，比如说根据scanner读入的一行字符寻找参数的函数，那么也应该在test类中定义好，然后给别的类调用，而不是
每个类中重新写一遍。

当然必须想清楚要复用的函数存不存在个性化定义的情况，因为这样会造成耦合度增大。如果单人开发，或者工程量较小的话可以这么做来减小维护的成本。

68.只要存在继承；方法重写；向上映射，那么多态就一定会发生，肯定会调用子类的方法而不是父类的方法。

69.var url  =  new URL("www.baidu.com")中的var关键字是java10的特性,用于设置一个局部变量,变量类型取决于等号右边对象的构造器.

70.pojo就是普通的javabeans.